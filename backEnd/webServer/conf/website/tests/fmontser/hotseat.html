<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Hot seat Tournament Pong Test Client (UNRANKED)</title>
	<style>
		body {
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			margin: 0;
			background-color: #1a1a1a;
		}
		canvas {
			border: 2px solid white;
		}
		#score {
			position: flex;
			width: 100%;
			text-align: center;
			top: 40px;
			color: white;
			font-size: 24px;
			font-family: monospace;
		}
	</style>
</head>
	<body>
		<div>
			<div id="score">0 - 0</div>
			<canvas id="playField" width="1280" height="720"></canvas>
		</div>

		<script>
			let matchMakerWS;
			let serverPongWS;
			const playField = document.getElementById('playField');
			const ctx = playField.getContext('2d');
			const scoreElement = document.getElementById('score');

			let PADDLE_WIDTH = 64;
			let PADDLE_HEIGHT = 256;
			let BALL_RADIUS = 32;

			let gameUID;
			let tournamentUID;

			let	player1UID;
			let	player1Name;
			let	player2UID;
			let	player2Name;

			let user1UID = 1; //TODO esto debe obtenerlo del perfil.
			let user2UID = 2; //TODO esto debe obtenerlo del perfil.
			let user3UID = 3; //TODO esto debe obtenerlo del perfil.
			let user4UID = 4; //TODO esto debe obtenerlo del perfil.

			let gameActive = false;
			let gameStarted = false;

			// Estado inicial
			let gameState = {
				ball: { x: 0, y: 0 },
				paddles: [
					{ x: 0, y: 0 },
					{ x: 0, y: 0 }
				],
				score: [0, 0]
			};
			//START

			setupMatchMakerWS();


			//MATCH MAKER SECTION

			function sendTournamentRequest() {
				matchMakerWS.send(JSON.stringify({
					type: 'hotSeatTournamentRequest',
					user1UID: user1UID,
					user2UID: user2UID,
					user3UID: user3UID,
					user4UID: user4UID
				}));
				console.log("Info: Hot seat tournament request sent to matchMaker");
			}

			function handleAnnounceResponse(data) {

				gameUID = data.gameUID;
				tournamentUID = data.tournamentUID;
				player1UID = data.player0UID;
				player1Name = data.player0Name;
				player2UID = data.player1UID;
				player2Name = data.player1Name;

				drawAnnounce();
				//Tres segundos de margen
				setTimeout(() => {
					setupPongWS();
				}, 3000);
			}

			function drawTornamentRanking(data) {
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				ctx.fillStyle = 'white';
				ctx.font = '48px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('TOURNAMENT RANKING', playField.width / 2, playField.height / 3);

				ctx.font = '36px monospace';
				ctx.fillText(`1st: UID ${data.p1}`, playField.width / 2, playField.height / 2 - 40);
				ctx.fillText(`2nd: UID ${data.p2}`, playField.width / 2, playField.height / 2 + 10);
				ctx.fillText(`3rd: UID ${data.p3}`, playField.width / 2, playField.height / 2 + 60);
				ctx.fillText(`4th: UID ${data.p4}`, playField.width / 2, playField.height / 2 + 110);
			}


			function setupMatchMakerWS() {
				matchMakerWS = new WebSocket(`wss://${window.location.hostname}:8443/matchmaker/front/post/hotseat`);

				matchMakerWS.onopen = () => {
					sendTournamentRequest();
				};

				matchMakerWS.onmessage = (event) => {
					const data = JSON.parse(event.data);
					switch(data.type) {
						case 'matchAnnounce':
							console.log("Info: Recieved match announce from matchMaker");
							handleAnnounceResponse(data);
							break;
						case 'tournamentRanking':
							console.log("Info: Recieved tournament ranking from matchMaker");
							drawTornamentRanking(data);
							break;
					}
				};

				window.onbeforeunload = () => {
					matchMakerWS.send(JSON.stringify({
						type: 'canceled',
						tournamentUID: tournamentUID
					}));

					serverPongWS.send(JSON.stringify({
						type: 'canceled'
					}));
				};

				matchMakerWS.onclose = () => {
					console.log('Disconected from match maker.')
				};

				matchMakerWS.onerror = (error) => {
					console.error('WebSocket error:', error);
				};

			}

			//TODO FRONTEND anuncio de juego!
			function drawAnnounce() {
				let countdown = 3;

				const drawCurrentAnnounceState = (currentCountdownValue) => {
					ctx.fillStyle = '#1a1a1a';
					ctx.fillRect(0, 0, playField.width, playField.height);

					ctx.fillStyle = 'white';
					ctx.font = '28px monospace';

					ctx.textAlign = 'left';
					const player0Display = `${player1Name || 'Player 0'} (UID: ${player1UID || 'N/A'})`;
					ctx.fillText(player0Display, 70, playField.height / 2 - 30);

					ctx.textAlign = 'right';
					const player1Display = `${player2Name || 'Player 1'} (UID: ${player2UID || 'N/A'})`;
					ctx.fillText(player1Display, playField.width - 70, playField.height / 2 - 30);

					ctx.textAlign = 'center';
					ctx.font = '36px monospace';
					ctx.fillText(`Match ID: ${gameUID || 'LOADING...'}`, playField.width / 2, playField.height / 2 - 100);

					if (currentCountdownValue > 0) {
						ctx.font = '120px monospace';
						ctx.fillStyle = 'yellow';
						ctx.fillText(currentCountdownValue.toString(), playField.width / 2, playField.height / 2 + 70);
					}
				};

				drawCurrentAnnounceState(countdown);

				const countdownInterval = setInterval(() => {
					countdown--;

					if (countdown > 0) {
						drawCurrentAnnounceState(countdown);
					} else {
						clearInterval(countdownInterval);
						ctx.fillStyle = '#1a1a1a';
						ctx.fillRect(0, 0, playField.width, playField.height);
					}
				}, 1000);
			}






			// ####################################
			// ####################################
			// ####################################








			//SERVER PONG SECTION

			function sendSetupRequest() {
				serverPongWS.send(JSON.stringify({
					type: 'setupRequest'
				}));
			}

			function startNewGame() {
				gameActive = true;
				serverPongWS.send(JSON.stringify({ 
					type: 'newGame',
					player1UID: player1UID,
					player2UID: player2UID
				}));
			}

			function handleSetupResponse(data) {
				PADDLE_WIDTH = data.paddleWidth;
				PADDLE_HEIGHT = data.paddleHeight;
				BALL_RADIUS = data.ballRadius;

				gameState.ball = data.ballPos;
				gameState.paddles = data.paddlesPos;
				gameState.score = data.score;

				startNewGame();
			}

			function reportTournament() {
				console.log("Info: Hot seat Tournament phase request sent to matchMaker");
				matchMakerWS.send(JSON.stringify({
					type: 'hotSeatTournamentPhaseEnd',
					tournamentUID: tournamentUID
				}));
			}

			function setupPongWS() {
				serverPongWS = new WebSocket(`wss://${window.location.hostname}:8443/serverpong/front/get/pong`);

				serverPongWS.onopen = () => {
					console.log('Conectado al servidor');
					sendSetupRequest();
					setupControls();
				};

				serverPongWS.onmessage = (event) => {
					const data = JSON.parse(event.data);
					switch(data.type) {
						case 'setupResponse':
							handleSetupResponse(data);
							break;
						case 'update':
							gameActive = true;
							gameState = data;
							drawFrame();
							break;
						case 'endGame':
							gameActive = false;
							gameStarted = false;
							drawEndGameScreen(data);
							setTimeout(() => {
								reportTournament();
							}, 3000);
							break;
					}
				};

				serverPongWS.onclose = () => {
					console.log('Disconected from pong server.');
				};

				serverPongWS.onerror = (error) => {
					console.error('WebSocket error:', error);
				};
			}

			function setupControls() {
				document.addEventListener('keydown', (event) => {
					let input = { type: 'input', playerSlot: 0, direction: 'stop' };
					
					switch(event.key) {
						case 'w':
							input.direction = 'up';
							input.playerSlot = 0;
							break;
						case 's':
							input.direction = 'down';
							input.playerSlot = 0;
							break;
						case 'ArrowUp':
							input.direction = 'up';
							input.playerSlot = 1;
							break;
						case 'ArrowDown':
							input.direction = 'down';
							input.playerSlot = 1;
							break;
					}
					
					serverPongWS.send(JSON.stringify(input));
				});

				document.addEventListener('keyup', (event) => {
					let input = { type: 'input', playerSlot: 0, direction: 'stop' };
					
					switch(event.key) {
						case 'w':
						case 's':
							input.playerSlot = 0;
							break;
						case 'ArrowUp':
						case 'ArrowDown':
							input.playerSlot = 1;
							break;
					}
					
					serverPongWS.send(JSON.stringify(input));
				});
			}

			//TODO FRONTEND dibujar cada frame
			function drawFrame() {
				// playField
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// paddles
				ctx.fillStyle = 'white';
				gameState.paddles.forEach(paddle => {
					ctx.fillRect(
						paddle.x,
						paddle.y,
						PADDLE_WIDTH,
						PADDLE_HEIGHT
					);
				});

				// ball
				ctx.beginPath();
				ctx.arc(gameState.ball.x, gameState.ball.y, BALL_RADIUS, 0, Math.PI * 2);
				ctx.fill();

				// score
				scoreElement.textContent = `${gameState.score[0]} - ${gameState.score[1]}`;
			}


			//TODO FRONTEND dibujar pantalla de fin de juego
			function drawEndGameScreen(endGameData) {
				// Limpiar canvas
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// Mostrar resultados
				ctx.fillStyle = 'white';
				ctx.font = '48px monospace';
				ctx.textAlign = 'center';
				
				// Título
				if (endGameData.type == 'playerDisconnected')
					ctx.fillText('RAGE QUIT!', playField.width/2, playField.height/3);
				else
					ctx.fillText('Game Over!', playField.width/2, playField.height/3);

				// Puntuación final
				ctx.font = '36px monospace';
				ctx.fillText(`Final Score: ${endGameData.score[0]} - ${endGameData.score[1]}`, 
					playField.width/2, playField.height/2);
				
				// Ganador
				ctx.fillText(`Winner: Player ${endGameData.winnerUID}`, 
					playField.width/2, playField.height/2 + 50);
			}


		</script>
	</body>
</html>