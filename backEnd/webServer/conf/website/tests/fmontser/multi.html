<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Multiplayer Pong Test Client</title>
	<style>
		body {
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			margin: 0;
			background-color: #1a1a1a;
		}
		canvas {
			border: 2px solid white;
		}
		#score {
			position: flex;
			width: 100%;
			text-align: center;
			top: 40px;
			color: white;
			font-size: 24px;
			font-family: monospace;
		}
	</style>
</head>
	<body>
		<div>
			<div id="score">0 - 0</div>
			<canvas id="playField" width="1280" height="720"></canvas>
		</div>

		<script>
			let ws;
			const playField = document.getElementById('playField');
			const ctx = playField.getContext('2d');
			const scoreElement = document.getElementById('score');

			let PADDLE_WIDTH = 64;
			let PADDLE_HEIGHT = 256;
			let BALL_RADIUS = 32;

			//TODO esto debe obtenerlo del perfil.
			let playerName;
			let playerUID = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
			let playerSlot;
			
			let rivalName;
			let rivalUID;
			let rivalSlot;

			let gameUID;
			let gameActive = false;
			let gameStarted = false;

			// Estado inicial
			let gameState = {
				ball: { x: 0, y: 0 },
				paddles: [
					{ x: 0, y: 0 },
					{ x: 0, y: 0 }
				],
				score: [0, 0]
			};
			//START

			setupMatchMakerWS();


			//MATCH MAKER SECTION

			function sendMatchRequest() {
				ws.send(JSON.stringify({
					type: 'matchRequest',
					playerUID: 1
				}));
			}

			function handleAnnounceResponse(data) {

				playerName = data.playerName;
				rivalName = data.rivalName;
				rivalUID = data.rivalUID;
				gameUID = data.gameUID;
				drawAnnounce();
				if (data.status == 'ongoing') {
					ws.close();
					setupPongWS();
				}
			}


			function setupMatchMakerWS() {
				ws = new WebSocket(`wss://${window.location.hostname}:8443/matchmaker/front/post/match`);

				ws.onopen = () => {
					sendMatchRequest();
				};

				ws.onmessage = (event) => {
					const data = JSON.parse(event.data);
					switch(data.type) {
						case 'matchAnnounce':
							handleAnnounceResponse(data);
							break;
					}
				};

				ws.onclose = () => {
					console.log('Disconected from match maker.');
				};

				ws.onerror = (error) => {
					console.error('WebSocket error:', error);
				};
			}

			//TODO FRONTEND presentar el anuncio del match
			function drawAnnounce() {
				//TODO
			}







			// ####################################
			// ####################################
			// ####################################








			//SERVER PONG SECTION

			function sendSetupRequest() {
				ws.send(JSON.stringify({
					type: 'setupRequest',
					playerUID: playerUID,
					gameUID: gameUID
				}));
			}

			function sendStartRequest() {
				ws.send(JSON.stringify({
					type: 'startRequest'
				}));
			}

			function handleSetupResponse(data) {
				PADDLE_WIDTH = data.paddleWidth;
				PADDLE_HEIGHT = data.paddleHeight;
				BALL_RADIUS = data.ballRadius;

				gameState.ball = data.ballPos;
				gameState.paddles = data.paddlesPos;
				gameState.score = data.score;
				playerSlot = data.playerSlot;

				drawStartScreen();
			}

			function setupPongWS() {
				ws = new WebSocket(`wss://${window.location.hostname}:8443/serverpong/front/get/multi`);

				ws.onopen = () => {
					console.log('Conectado al servidor');
					requestGameSetup();
				};

				ws.onmessage = (event) => {
					const data = JSON.parse(event.data);
					switch(data.type) {
						case 'setupResponse':
							handleSetupResponse(data);
							break;
						case 'update':
							gameActive = true;
							gameState = data;
							drawFrame();
							break;
						case 'endGame':
							gameActive = false;
							gameStarted = false;
							drawEndGameScreen(data);
							break;
						//TODO pantalla resultados con desconexion de jugador... case 'playerDisconnected'
					}
				};

				ws.onclose = () => {
					console.log('Disconected from pong server.');
				};

				ws.onerror = (error) => {
					console.error('WebSocket error:', error);
				};
			}

			function setupControls() {
				document.addEventListener('keydown', (event) => {
					let input = { type: 'input', playerSlot: playerSlot, direction: 'stop' };
					if (playerSlot == 0) {
						switch(event.key) {
							case 'w':
								input.direction = 'up';
								ws.send(JSON.stringify(input));
								break;
							case 's':
								input.direction = 'down';
								ws.send(JSON.stringify(input));
								break;
						}
					} else if (playerSlot == 1) {
						switch(event.key) {
							case 'ArrowUp':
								input.direction = 'up';
								ws.send(JSON.stringify(input));
								break;
							case 'ArrowDown':
								input.direction = 'down';
								ws.send(JSON.stringify(input));
								break;
						}
					}
				});

				document.addEventListener('keyup', (event) => {
					let input = { type: 'input', playerSlot: playerSlot, direction: 'stop' };
					
					if (playerSlot == 0) {
						switch(event.key) {
							case 'w':
							case 's':
								ws.send(JSON.stringify(input));
								break;
						}
					} else if (playerSlot == 1) {
						switch(event.key) {
							case 'ArrowUp':
							case 'ArrowDown':
								ws.send(JSON.stringify(input));
								break;
						}
					}
				});
			}

			//TODO FRONTEND dibujar cada frame
			function drawFrame() {
				// playField
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// paddles
				ctx.fillStyle = 'white';
				gameState.paddles.forEach(paddle => {
					ctx.fillRect(
						paddle.x,
						paddle.y,
						PADDLE_WIDTH,
						PADDLE_HEIGHT
					);
				});

				// ball
				ctx.beginPath();
				ctx.arc(gameState.ball.x, gameState.ball.y, BALL_RADIUS, 0, Math.PI * 2);
				ctx.fill();

				// score
				scoreElement.textContent = `${gameState.score[0]} - ${gameState.score[1]}`;
			}

			//TODO FRONTEND dibujar la pantalla de inicio
			function drawStartScreen() {
				// Fondo
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// Título
				ctx.fillStyle = 'white';
				ctx.font = '48px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('PONG', playField.width/2, playField.height/3);

				// Botón de inicio
				const buttonY = playField.height/2 + 50;
				ctx.fillStyle = '#4CAF50';
				ctx.fillRect(playField.width/2 - 100, buttonY, 200, 50);
				
				ctx.fillStyle = 'white';
				ctx.font = '24px monospace';
				ctx.fillText('Start Game', playField.width/2, buttonY + 32);

				// Listener para el botón
				playField.addEventListener('click', handleStartClick);
			}

			//TODO FRONTEND dibujar pantalla de fin de juego
			function drawEndGameScreen(endGameData) {
				// Limpiar canvas
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// Mostrar resultados
				ctx.fillStyle = 'white';
				ctx.font = '48px monospace';
				ctx.textAlign = 'center';
				
				// Título
				ctx.fillText('Game Over!', playField.width/2, playField.height/3);
				
				// Puntuación final
				ctx.font = '36px monospace';
				ctx.fillText(`Final Score: ${endGameData.score[0]} - ${endGameData.score[1]}`, 
					playField.width/2, playField.height/2);
				
				// Ganador
				ctx.fillText(`Winner: Player ${endGameData.winnerUID}`, 
					playField.width/2, playField.height/2 + 50);

				// Botón de nueva partida
				const buttonY = playField.height/2 + 120;
				ctx.fillStyle = '#4CAF50';
				ctx.fillRect(playField.width/2 - 100, buttonY, 200, 50);
				
				ctx.fillStyle = 'white';
				ctx.font = '24px monospace';
				ctx.fillText('New Game', playField.width/2, buttonY + 32);

				// Añadir listener para el click en el botón
				playField.addEventListener('click', handleNewGameClick);
			}

			//TODO FRONTEND local event handlers, botones etc...
			function handleStartClick(event) {
				const rect = playField.getBoundingClientRect();
				const x = event.clientX - rect.left;
				const y = event.clientY - rect.top;
				
				const buttonY = playField.height/2 + 50;
				if (x >= playField.width/2 - 100 && x <= playField.width/2 + 100 &&
					y >= buttonY && y <= buttonY + 50) {
					
					playField.removeEventListener('click', handleStartClick);
					gameStarted = true;
				}
			}

			//TODO FRONTEND local event handlers, botones etc...
			function handleNewGameClick(event) {
				const rect = playField.getBoundingClientRect();
				const x = event.clientX - rect.left;
				const y = event.clientY - rect.top;
				
				// Comprobar si el click fue en el botón
				if (x >= playField.width/2 - 100 && x <= playField.width/2 + 100 &&
					y >= playField.height/2 + 120 && y <= playField.height/2 + 170) {
					
					// Remover el listener para evitar múltiples clicks
					playField.removeEventListener('click', handleNewGameClick);
					ws.close();
					setupMatchMakerWS();
				}
			}
		</script>
	</body>
</html>