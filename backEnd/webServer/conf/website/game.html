<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Pong Test Client</title>
	<style>
		body {
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			margin: 0;
			background-color: #1a1a1a;
		}
		canvas {
			border: 2px solid white;
		}
		#score {
			position: absolute;
			top: 20px;
			color: white;
			font-size: 24px;
			font-family: monospace;
		}
	</style>
</head>
<body>
	<div>
		<div id="score">0 - 0</div>
		<canvas id="playField" width="1280" height="720"></canvas>
	</div>

	<script>
		const ws = new WebSocket(`wss://${window.location.hostname}:8443/serverpong/front/get/pong`);
		const playField = document.getElementById('playField');
		const ctx = playField.getContext('2d');
		const scoreElement = document.getElementById('score');

		const PADDLE_WIDTH = 64;
		const PADDLE_HEIGHT = 256;
		const BALL_RADIUS = 32;

		// Estado inicial
		let gameState = {
			ball: { x: playField.width/2, y: playField.height/2 }, // La pelota sigue centrada
			paddles: [
				{ x: 32, y: (playField.height - PADDLE_HEIGHT)/2 }, // Paddle izquierdo, anclado a esquina
				{ x: playField.width - 32 - PADDLE_WIDTH, y: (playField.height - PADDLE_HEIGHT)/2 } // Paddle derecho, anclado a esquina
			],
			score: [0, 0]
		};

		// Manejo de WebSocket
		ws.onopen = () => {
			//TODO dibujar un pantalla de inicio con un boton para empezar, la pulsar se envia newGame
			ws.send(JSON.stringify({ type: 'newGame', player1UID: 1, player2UID: 2 }));
		};

		ws.onmessage = (event) => {
			//TODO deberia dibujarse por primera vez al recibir el primer update...
			switch(event.type) {
				case 'update':
					gameState = JSON.parse(event.data);
					drawGame();
					break;
				case 'endGame':
					//TODO dibujar pantalla de resultados.
					break;
			}
		};

		ws.onclose = () => {
			console.log('Desconectado del servidor');
		};

		function drawGame() {
			// playField
			ctx.fillStyle = '#1a1a1a';
			ctx.fillRect(0, 0, playField.width, playField.height);

			// paddles
			ctx.fillStyle = 'white';
			gameState.paddles.forEach(paddle => {
				ctx.fillRect(
					paddle.x,
					paddle.y,
					PADDLE_WIDTH,
					PADDLE_HEIGHT
				);
			});

			// vall
			ctx.beginPath();
			ctx.arc(gameState.ball.x, gameState.ball.y, BALL_RADIUS, 0, Math.PI * 2);
			ctx.fill();

			// score
			scoreElement.textContent = `${gameState.score[0]} - ${gameState.score[1]}`;
		}

		// control
		document.addEventListener('keydown', (event) => {
			let input = { type: 'input', playerId: 0, direction: 'stop' };
			
			switch(event.key) {
				case 'w':
					input.direction = 'up';
					input.playerId = 0;
					break;
				case 's':
					input.direction = 'down';
					input.playerId = 0;
					break;
				case 'ArrowUp':
					input.direction = 'up';
					input.playerId = 1;
					break;
				case 'ArrowDown':
					input.direction = 'down';
					input.playerId = 1;
					break;
			}
			
			ws.send(JSON.stringify(input));
		});

		document.addEventListener('keyup', (event) => {
			let input = { type: 'input', playerId: 0, direction: 'stop' };
			
			switch(event.key) {
				case 'w':
				case 's':
					input.playerId = 0;
					break;
				case 'ArrowUp':
				case 'ArrowDown':
					input.playerId = 1;
					break;
			}
			
			ws.send(JSON.stringify(input));
		});

		drawGame();

	</script>
</body>
</html>