<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Multiplayer Pong Test Client</title>
	<style>
		body {
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			margin: 0;
			background-color: #1a1a1a;
		}
		canvas {
			border: 2px solid white;
		}
		#score {
			position: flex;
			width: 100%;
			text-align: center;
			top: 40px;
			color: white;
			font-size: 24px;
			font-family: monospace;
		}
	</style>
</head>
	<body>
		<div>
			<div id="score">0 - 0</div>
			<canvas id="playField" width="1280" height="720"></canvas>
		</div>

		<script>
			let ws;
			const playField = document.getElementById('playField');
			const ctx = playField.getContext('2d');
			const scoreElement = document.getElementById('score');

			let PADDLE_WIDTH = 64;
			let PADDLE_HEIGHT = 256;
			let BALL_RADIUS = 32;

			let gameUID;
			let userUID = 2; //TODO esto debe obtenerlo del perfil.
			let userSlot;

			let player0Name;
			let player0UID;
			let player1Name;
			let player1UID;

			let gameActive = false;
			let gameStarted = false;

			// Estado inicial
			let gameState = {
				ball: { x: 0, y: 0 },
				paddles: [
					{ x: 0, y: 0 },
					{ x: 0, y: 0 }
				],
				score: [0, 0]
			};
			//START

			setupMatchMakerWS();


			//MATCH MAKER SECTION

			function sendMatchRequest() {
				ws.send(JSON.stringify({
					type: 'matchRequest',
					userUID: userUID
				}));
				console.log("Info: Match request sent to matchMaker");
			}

			function handleAnnounceResponse(data) {

				gameUID = data.gameUID;
				player0UID = data.player0UID;
				player0Name = data.player0Name;
				player1UID = data.player1UID;
				player1Name = data.player1Name;

				if (player0UID == userUID)
					userSlot = 0;
				else
					userSlot = 1;

				drawAnnounce();
				//Tres segundos de margen
				setTimeout(() => {
					ws.close();
					setupPongWS();
				}, 3000);
			}


			function setupMatchMakerWS() {
				ws = new WebSocket(`wss://${window.location.hostname}:8443/matchmaker/front/post/match`);

				ws.onopen = () => {
					sendMatchRequest();
				};

				ws.onmessage = (event) => {
					const data = JSON.parse(event.data);
					switch(data.type) {
						case 'matchAnnounce':
							console.log("Info: Recieved match announce from matchMaker");
							handleAnnounceResponse(data);
							break;
					}
				};

				ws.onclose = () => {
					console.log('Disconected from match maker.');
				};

				ws.onerror = (error) => {
					console.error('WebSocket error:', error);
				};
			}

			//TODO FRONTEND anuncio de juego!
			function drawAnnounce() {
				let countdown = 3;

				const drawCurrentAnnounceState = (currentCountdownValue) => {
					ctx.fillStyle = '#1a1a1a';
					ctx.fillRect(0, 0, playField.width, playField.height);

					ctx.fillStyle = 'white';
					ctx.font = '28px monospace';

					ctx.textAlign = 'left';
					const player0Display = `${player0Name || 'Player 0'} (UID: ${player0UID || 'N/A'})`;
					ctx.fillText(player0Display, 70, playField.height / 2 - 30);

					ctx.textAlign = 'right';
					const player1Display = `${player1Name || 'Player 1'} (UID: ${player1UID || 'N/A'})`;
					ctx.fillText(player1Display, playField.width - 70, playField.height / 2 - 30);

					ctx.textAlign = 'center';
					ctx.font = '36px monospace';
					ctx.fillText(`Match ID: ${gameUID || 'LOADING...'}`, playField.width / 2, playField.height / 2 - 100);

					if (currentCountdownValue > 0) {
						ctx.font = '120px monospace';
						ctx.fillStyle = 'yellow';
						ctx.fillText(currentCountdownValue.toString(), playField.width / 2, playField.height / 2 + 70);
					}
				};

				drawCurrentAnnounceState(countdown);

				const countdownInterval = setInterval(() => {
					countdown--;

					if (countdown > 0) {
						drawCurrentAnnounceState(countdown);
					} else {
						clearInterval(countdownInterval);
						ctx.fillStyle = '#1a1a1a';
						ctx.fillRect(0, 0, playField.width, playField.height);
					}
				}, 1000);
			}






			// ####################################
			// ####################################
			// ####################################








			//SERVER PONG SECTION

			function sendSetupRequest() {
				ws.send(JSON.stringify({
					type: 'setupRequest',
					userUID: userUID,
					userSlot: userSlot,
					gameUID: gameUID
				}));
			}

			function sendStartRequest() {
				ws.send(JSON.stringify({
					type: 'startRequest',
					userUID: userUID
				}));
			}

			function handleSetupResponse(data) {
				PADDLE_WIDTH = data.paddleWidth;
				PADDLE_HEIGHT = data.paddleHeight;
				BALL_RADIUS = data.ballRadius;

				gameState.ball = data.ballPos;
				gameState.paddles = data.paddlesPos;
				gameState.score = data.score;

				sendStartRequest();
			}

			function setupPongWS() {
				ws = new WebSocket(`wss://${window.location.hostname}:8443/serverpong/front/get/game`);

				ws.onopen = () => {
					console.log('Conectado al servidor');
					sendSetupRequest();
					setupControls();
				};

				ws.onmessage = (event) => {
					const data = JSON.parse(event.data);
					switch(data.type) {
						case 'setupResponse':
							handleSetupResponse(data);
							break;
						case 'update':
							gameActive = true;
							gameState = data;
							drawFrame();
							break;
						case 'endGame':
						case 'playerDisconnected':
							gameActive = false;
							gameStarted = false;
							drawEndGameScreen(data);
							break;

						//TODO pantalla resultados con desconexion de jugador... case 'playerDisconnected'
					}
				};

				ws.onclose = () => {
					console.log('Disconected from pong server.');
				};

				ws.onerror = (error) => {
					console.error('WebSocket error:', error);
				};
			}

			function setupControls() {

				console.log("Intentando añadir event listeners para controles. userSlot actual:", userSlot);
				document.addEventListener('keydown', (event) => {
					let input = { type: 'input', playerSlot: userSlot, direction: 'stop' };
					if (userSlot == 0) {
						switch(event.key) {
							case 'w':
								input.direction = 'up';
								ws.send(JSON.stringify(input));
								break;
							case 's':
								input.direction = 'down';
								ws.send(JSON.stringify(input));
								break;
						}
					} else if (userSlot == 1) {
						switch(event.key) {
							case 'ArrowUp':
								input.direction = 'up';
								ws.send(JSON.stringify(input));
								break;
							case 'ArrowDown':
								input.direction = 'down';
								ws.send(JSON.stringify(input));
								break;
						}
					}
				});

				document.addEventListener('keyup', (event) => {
					let input = { type: 'input', playerSlot: userSlot, direction: 'stop' };
					
					if (userSlot == 0) {
						switch(event.key) {
							case 'w':
							case 's':
								ws.send(JSON.stringify(input));
								break;
						}
					} else if (userSlot == 1) {
						switch(event.key) {
							case 'ArrowUp':
							case 'ArrowDown':
								ws.send(JSON.stringify(input));
								break;
						}
					}
				});
			}

			//TODO FRONTEND dibujar cada frame
			function drawFrame() {
				// playField
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// paddles
				ctx.fillStyle = 'white';
				gameState.paddles.forEach(paddle => {
					ctx.fillRect(
						paddle.x,
						paddle.y,
						PADDLE_WIDTH,
						PADDLE_HEIGHT
					);
				});

				// ball
				ctx.beginPath();
				ctx.arc(gameState.ball.x, gameState.ball.y, BALL_RADIUS, 0, Math.PI * 2);
				ctx.fill();

				// score
				scoreElement.textContent = `${gameState.score[0]} - ${gameState.score[1]}`;
			}


			//TODO FRONTEND dibujar pantalla de fin de juego
			function drawEndGameScreen(endGameData) {
				// Limpiar canvas
				ctx.fillStyle = '#1a1a1a';
				ctx.fillRect(0, 0, playField.width, playField.height);

				// Mostrar resultados
				ctx.fillStyle = 'white';
				ctx.font = '48px monospace';
				ctx.textAlign = 'center';
				
				// Título
				if (endGameData.type == 'playerDisconnected')
					ctx.fillText('RAGE QUIT!', playField.width/2, playField.height/3);
				else
					ctx.fillText('Game Over!', playField.width/2, playField.height/3);

				// Puntuación final
				ctx.font = '36px monospace';
				ctx.fillText(`Final Score: ${endGameData.score[0]} - ${endGameData.score[1]}`, 
					playField.width/2, playField.height/2);
				
				// Ganador
				ctx.fillText(`Winner: Player ${endGameData.winnerUID}`, 
					playField.width/2, playField.height/2 + 50);
			}


		</script>
	</body>
</html>